# 201604-4 Ê∏∏ÊàèüéÆ [SPFA]

```c++
//#include<bits/stdc++.h>
#include<iostream>
#include<queue>
using namespace std;
const int maxN=1e2+5;
int n,m,t,danger1[maxN][maxN],danger2[maxN][maxN];
int vis[maxN][maxN],dis[maxN][maxN];
int movement[4][2]={{1,0},{-1,0},{0,1},{0,-1}};
int main(){
    cin>>n>>m>>t;
    fill(danger1[0],danger1[0]+maxN*maxN,0);
    fill(danger2[0],danger2[0]+maxN*maxN,0);
    fill(vis[0],vis[0]+maxN*maxN,0);
    fill(dis[0],dis[0]+maxN*maxN,INT_MAX);
    int r,c,a,b;
    for(int i=0;i<t;i++){
        cin>>r>>c>>a>>b;
        danger1[r][c]=a;
        danger2[r][c]=b;
    }
    struct p{int x,y;};
    queue<p> q;
    q.push({1,1});
    dis[1][1]=0;
    int x,y,t,x_temp,y_temp;
    while(!q.empty()){
        x=q.front().x;
        y=q.front().y;
        t=dis[x][y]+1;
        vis[x][y]=0;
        if(x==n&&y==m){
            cout<<dis[x][y]<<endl;
            return 0;
        }
        //cout<<x<<" "<<y<<endl;
        q.pop();
        for(int i=0;i<4;i++){
            x_temp=x+movement[i][0];
            y_temp=y+movement[i][1];
            if(x_temp<=n&&x_temp>=1&&y_temp<=n&&y_temp>=1){
                if(t<=danger2[x_temp][y_temp]&&t>=danger1[x_temp][y_temp])
                    continue;
                if(vis[x_temp][y_temp])
                    continue;
                /*if(dis[x_temp][y_temp]<t)
                    continue;*/
                dis[x_temp][y_temp]=t;
                vis[x_temp][y_temp]=1;
                q.push({x_temp,y_temp});
            }
        }
        
    }
    cout<<dis[n][m]<<endl;
    return 0;
}
/*
3 3 3
2 1 1 1
1 3 2 10
2 2 2 10

 */

```

